- **참조블로그**

  [[기술면접] CS 기술면접 질문 - 프로그래밍 공통 (1/8)](https://mangkyu.tistory.com/88)


## 1. 프로그래밍 공통


### RESTful API

- `RE`presentational `S`tate `T`ransfer
- HTTP 통신에서, 어떤 자원에 대한 CRUD 요청을 Resource와 Method로 표현하여 특정한 형태로 전달하는 방식
  - Resource - 자원, URI
  - Method - 요청 방식, GET, POST 등
  - Representation of Resource (자원의 형태, JSON, XML)
  - 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일

### 메모리 구조

![](https://blog.kakaocdn.net/dn/nyV7n/btqITvcHjTA/dk2V9ejhCT1P5Zngumuag1/img.png)

- **코드 영역**
  - 실행할 프로그램의 코드가 저장되는 영역, 텍트스 영역
  - 실행 명령 → OS가 코드를 HDD → 메모리로 올림 → CPU는 코드 영역의 명령어를 하나씩 처리함
- **데이터 영역**
  - 전역 변수, 정적 변수가 저장됨, 프로그램의 시작과 함께 할당된다
- **힙 영역**
  - 프로그래머가 직접 관리할 수 있는 메모리 영역, 동적 할당.
  - 낮은 주소 → 높은 주소
- **스택 영역**
  - 함수의 호출과 함께 할당됨, 지역 변수와 매개 변수가 저장된다.
  - 높은 주소 → 낮은 주소

### parameter vs argument

- **parameter** : 매개변수
  - 함수를 선언할 때 사용된 변수
- **argument** : 인자
  - 함수가 호출되었을 때 함수의 파라미터로 전달된 실제 값

### Call by **`Value`** vs Call by `Reference`

- **value**
  - 인자로 받은 값을 복사하여 처리한다 → 원래의 값 보존, 메모리 사용량 증가
- **reference**
  - 인자로 받은 값의 주소를 참조 → 직접 값에 영향, 속도가 빠름

### 프레임워크와 라이브러리

키포인트 : **실행 흐름**에 대한 **제어 권한**이 어디있는가?

- **프레임워크**
  - 전체적인 흐름을 자체적으로 제어
- **라이브러리**
  - 사용자가 흐름에 대한 제어를 함, 필요한 상황에 가져다 쓸 수 있다

### 동기와 비동기

- **동기 방식**
  - 요청을 보내고 **실행이 끝나면** 다음 동작을 처리
  - **순서**에 맞추어 진행됨 → 제어하기 쉽다.
  - 여러 요청을 동시에 처리할 수 없음
- **비동기 방식**
  - 요청을 보내고 해당 동작의 **처리 여부와 상관 없이 다음 요청**이 동작
  - 작업이 완료되는 시간을 기다릴 필요가 없기 때문에 **자원을 효율적**으로 사용
  - 작업이 완료된 결과를 제어하기 어렵다.

### 메시지 큐

- Queue 자료구조를 이용해 데이터(메시지)를 관리하는 시스템
- 비동기 통신 프로토콜을 제공하여 메시지를 빠르게 주고받을 수 있음.
- Producer(생산자)가 넣음, Consumer가 가져와 처리
- Kafka, Rabbit MQ, AMPQ

### TDD(Test-Driven-Development)

- 매우 짧은 개발 사이클의 반복에 의존하는 개발 프로세스
- 요구되는 기능에 대한 테스트케이스 작성 → 코드 작성 → 테스트 통과 → 상황에 맞게 리팩토링
- 개발자는 테스트를 작성하기 위해 요구사항을 확실히 이해해야

## 2. 자료구조


### 자료구조와 알고리즘

- 자료구조 : 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조
- 알고리즘 : 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임

### 스택, 큐, 트리, 힙

- 스택 : FILO
- 큐 : FIFO
- 트리 : 정점과 간선을 이용해 사이클을 이루지 않도록 구성한 Graph의 특수한 형태
- 힙 : 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조 - 완전이진트리

### 우선순위 큐

- 우선순위가 높은 데이터를 먼저 꺼내가 위해 고안된 자료구조
- 힙 자료구조 사용, 시간복잡도 `O(logn)`

### 해시테이블

- key, value로 데이터를 저장하는 자료구조 중 하나
- 빠른 데이터 검색이 필요할 때 유용함
- key값에 해시함수를 적용해 고유한 index 생성, 그 index에 저장된 값을 꺼내온다. `O(1)`

### LinkedList, ArrayList

- **array**
  - 데이터들이 순서대로 늘어선 배열의 형식
  - 원하는 데이터에 무작위로 접근 가능
  - 리스트 크기 재조정에 어려움
  - 추가/삭제를 위해 임시 배열을 생성하고 복제하기 때문에 시간이 오래 걸림
- **linked**
  - 자료의 주소값으로 서로 연결된 형식
  - 무작위 접근 불가능, 순차 접근
  - 리스트의 크기에 영향이 없이 데이터 추가
  - 새로운 노드를 생성하여 주소만 연결하면 됨, 추가 삭제 연산이 빠르다.

## 3. 알고리즘

---

### 정렬 알고리즘

![](https://blog.kakaocdn.net/dn/Fffzd/btqIYas3Ij5/ow6oK7GS6faEe1XQPZ65vK/img.png)

- **버블 소트**
  - 버블 소트 그림

    ![](https://blog.kakaocdn.net/dn/cqNUzB/btqITvdyGGF/wu13gRsZ8myIkDlk0WAmx0/img.png)

  - 서로 인접한 두 원소를 비교하여 정렬하는 알고리즘, 큰 원소가 위로 보글보글 올라옴
  - 모든 인덱스를 비교하며 정렬, `O(n^2)`
- **힙 소트**
  - 힙 소트 그림

    ![](https://blog.kakaocdn.net/dn/PgySh/btqITur6oYn/hLYHRVgkKimBNG6rwd5Q6k/img.png)

  - 주어진 데이터를 힙 자료구조로 만들어 최대값 또는 최소값부터 하나씩 꺼내어 정렬하는 알고리즘
  - 전체를 정렬하는 것이 아닌, 가장 큰 값 몇 개만 필요한 경우 유용하다
  - `O(nlogn)`
- **머지 소트**
  - 머지 소트 그림

    ![](https://blog.kakaocdn.net/dn/MaPX2/btqIWS0GAuO/igmIkXQjYxm5ObNcVaSp71/img.png)

  - 주어진 배열을 크기가 1인 배열로 분할, 합병하면서 정렬을 진행하는 분할/정복 알고리즘
  - `O(nlogn)`
- **퀵 소트**
  - 퀵 소트 그림

    ![](https://blog.kakaocdn.net/dn/ykKjA/btqLhQxCApg/thkLcCfbJVYidkW5K9ntx0/img.jpg)

  - 합병 정렬과 달리 리스트를 비균등하게 분할
  - 피봇을 설정한 후 피봇보다 큰 값과 작은 값으로 분할
  - `O(nlogn)`, 리스트가 계속해서 불균형한 경우 `O(n^2)`
- **삽입정렬**
  - 삽입 정렬 그림

    ![](https://blog.kakaocdn.net/dn/PhpP8/btq2HtsuB7M/EEltFOR1urUBTLl1baDJC1/img.png)

  - 두 번째 값부터 시작, 앞의 원소와 값을 비교하여 삽입할 위치를 찾아 삽입
  - `O(n^2)`, 빠르면 `O(n)`

### 동적 프로그래밍

- 문제를 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 해결하는 방식이다.
- 어떤 부분 문제가 다른 문제를 해결하는 데 사용될 수 있음
  - 한 번만 계산하고 그 결과를 재활용하는 메모이제이션 기법으로 속도 향상
- 주어진 문제는 **같은 부분 문제**가 여러 번 재사용된다.
- 새로운 부분 문제의 정답을 **다른 부분 문제**의 정답으로 구할 수 있다.

### 재귀 알고리즘

- 함수 내부에서 함수가 자기 자신을 또 다시 호출하여 문제를 해결하는 알고리즘
- 계속해서 자신을 호출하기 때문에, 반드시 반복을 중단할 조건이 필요함

## 4. 네트워크


### 브라우저에 "www.naver.com"를 치면?

[웹 브라우저에 URL을 입력하면 어떤 일이 생기나요? | Amazon Web Services](https://aws.amazon.com/ko/blogs/korea/what-happens-when-you-type-a-url-into-your-browser/)

![](https://blog.kakaocdn.net/dn/dmomKO/btqK84xb9yy/ktAElZQp6AFyxgXG35eORk/img.png)

1. 브라우저에 url을 입력한다.
2. DNS 조회를 수행하여 도메인 이름 naver.com을 기반으로 서버의 IP 주소를 찾는다.
3. 웹 브라우저가 서버와의 TCP 연결 시작 - 3 Way Handshake
4. 리소스 또는 페이지를 가져오기 위해 HTTP 요청을 전송

   페이지의 콘텐츠를 요청하기 위해 서버에 HTTP 요청을 전송한다.

   요청 라인 : GET, POST, PUT, PATCH, DELETE 등의 **요청 메서드**
   요청된 리소스를 가리키는 **경로**
   통신할 **HTTP 버전**

5. 웹 브라우저가 서버로부터 응답을 받음

   응답 헤더를 검사하여 **리소스를 렌더링하는 방법**에 대한 정보를 확인

   브라우저가 **HTML**을 파싱하고 렌더링 → **다른 Javascript, CSS, 이미지 리소스**를 참조하고 웹 페이지를 설계된대로 렌더링하기 위해 **추가 데이터를 요청**


### TCP와 UDP의 차이

4계층(전송 계층)에서 사용되는 프로토콜입니다!

- 전송 계층
  - IP에 의해 전달되는 패킷의 **오류를 검사**하고 **재전송 요구** 등의 **제어**를 담당하는 계층

- TCP - `T`ransmission `C`ontrol `P`rotocol
  - 3-way handshaking, 4-way handshaking
  - 신뢰성이 요구되는 애플리케이션에서 사용(일반적인 애플리케이션)
- UDP - `U`ser `D`atagram `P`rotocol
  - 간단한 데이터를 빠른 속도로 전송하고자 할 때
  - 음성이나 동영상 데이터를 수신할 경우

### GET과 POST 차이

- GET
  - 데이터를 조회하기 위해 사용, 데이터를 **헤더**에 추가
  - URL이 노출되므로 보안적으로 중요한 데이터를 포함하면 안됨
- POST
  - 데이터를 추가, 또는 수정하기 위해 사용되는 방식
  - 데이터를 **바디**에 추가

### 공인 IP, 사설 IP

- 공인 IP
  - 전세계에서 유일한 IP, ISP(internet service provider)에서 제공하는 IP 주소
  - 다른 장비로부터 접근 가능 → 방화벽같은 보안설정
  - 한정된 개수(IPv4) → 사설IP(192.168.0.1), IPv6의 등장
- 사설 IP
  - 어떤 네트워크 안에서 사용되는 IP 주소
  - 네트워크 안에서 라우터를 통해 할당받음
  - 별도의 설정 없이는 외부에서 접근 불가능

### OSI 7 layer

**[7 계층]** 응용 계층

- 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층

**[6 계층]** 표현 계층

- 데이터의 형식을 정의하는 계층

**[5 계층]** 세션 계층

- 컴퓨터끼리 통신을 하기 위한 세션을 만드는 계층

**[4 계층]** 전송 계층

- 최종 수신 프로세스로, 데이터의 전송을 담당

**[3 계층]** 네트워크 계층

- 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층

**[2 계층]** 데이터링크 계층

- 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당

**[1 계층]** 물리 계층

- 데이터를 전기 신호로 바꾸어주는 계층

### HTTP 프로토콜

- `H`yper `T`ext `T`ransfer `P`rotocol
- **서버/클라이언트 모델**을 따라 데이터를 주고받기 위한 프로토콜
- **connectionless**
  - 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어, **연결을 유지하지 않는 것**
  - 서버의 자원을 효율적으로 관리할 수 있음
  - 하지만 매번 3-way handshaking 후 자원을 받고 끊고…. 오히려 시간이 오래걸림

  ⇒ **HTTP 지속 연결**

  - 연결된 후 일정 시간 연결을 유지하거나, 여러 개의 요청에 대한 응답이 다 올 때까지 기다린 후 연결을 종료
- **stateless**
  - 서버가 클라이언트의 **이전 상태**를 **보존하지 않는 것**
  - 끊겼다가 다시 연결되어도 클라이언트를 기억하기 위해!!
    - 쿠키, 서버 세션, JWT 등의 방식을 이용.

### HTTP vs HTTPS

- HTTP는 평문 데이터를 전송하는 프로토콜
  - 중간에 패킷을 탈취당하면 중요 내용을 제 3자에게 탈취당할 수 있음

  ⇒ HTTP에 암호화를 추가하자

- **HTTPS**
  - **대칭키 암호화, 비대칭키 암호화** 모두 사용
  - https://100100e.tistory.com/317
    - 최초 연결 1회 : 대칭키를 공유하기 위한 과정에서 비대칭키 암호화 사용
    - 메시지를 주고받을 때는 대칭키 암호화 사용
      1. 클라이언트가 서버로 최초 연결 시도
      2. 서버는 **공개키(인증서)**를 브라우저에게 넘겨줌
      3. 브라우저는 **인증서**의 유효성을 검사 후 **세션키 발급**
      4. 브라우저는 **세션키를 보관**
         **서버의 공개키**로 **세션키**를 암호화 → 서버로 전송
      5. 서버는 **암호화된 세션키**를 **개인키**로 **복호화**
      6. 클라이언트와 서버는 **동일한 세션키**를 공유
         데이터를 전달할 때 **세션키로 암호화/복호화** 진행
  - 공개키로 암호화된 메시지는 개인키를 가지고 있어야만 복호화가 가능

  ⇒ **서버를 제외한 누구도 원본 데이터를 얻을 수 없다.**


## 5. 운영체제

---

### Byte Ordering

데이터가 저장되는 순서

![](https://blog.kakaocdn.net/dn/d61BQv/btqKGke14cT/XuxbH4w5qfkvybCbQVmiFK/img.png)

- **Big Endian**
  - MSB(the Most Significant Byte)가 가장 낮은 주소에 위치하는 방식
    - offset=0인 Byte를 보면 양수/음수를 바로 파악할 수 있다.
  - 네트워크에서 데이터를 전송할 때 주로 사용됨
- **Little Endian**
  - MSB가 가장 높은 주소에 위치하는 방식
    - 가장 낮은 주소에 데이터가 오므로 바로 연산 가능
  - 마이크로프로세서에서 주로 사용됨

### 프로세스와 스레드의 차이

- **프로세스**
  - 메모리에 올라와 **실행**되고 있는 **프로그램의 인스턴스**
  - 운영체제로부터 **독립된 메모리 영역**을 할당받음
  - 각 프로세스는 독립적 → 프로세스들 끼리 통신하려면 **IPC** 사용
  - 프로세스는 **최소 1개의 스레드**를 가진다
- **스레드**
  - **프로세스 내**에서 **할당받은 자원(메모리 영역)**을 이용해 동작하는 실행 단위
  - 프로세스 내 **Stack만 따로 할당받음**
    - Stack에는 함수의 호출정보가 저장되는데, Stack을 공유하면 LIFO 구조에 의해 실행 순서가 복잡해지기 때문에 실행 흐름을 원활하게 만들기 위함이다.
  - **Code, Data, Heap 영역은 공유한다**
    - 프로세스가 할당받은 자원을 공유 ⇒ 다른 쓰레드에 의한 결과를 즉시 확인할 수 있다.

### 멀티 프로세스 vs 멀티 쓰레드

- **멀티 프로세스**
  - 하나의 프로그램을 여러 개의 프로세스로 구성, 각 **프로세스가 1개의 작업을 처리**
  - 1개의 프로세스가 죽음 → 자식 프로세스도 죽음

    이외의 **다른 프로세스들은 계속 실행된다**

  - 프로세스 → **독립된 메모리 영역** 할당 → 통신이 어려움
  - 컨텍스트 스위칭을 위한 오버헤드가 발생한다.
- **멀티 쓰레드**
  - 하나의 프로그램을 여러 개의 쓰레드로 구성하여 각 **쓰레드가 1개의 작업을 처리**하도록 하는 것
  - 하나의 쓰레드에 문제 → **전체 프로세스가 영향을 받음**
  - **메모리를 공유**하므로 통신이 쉽고 자원을 효율적으로 사용할 수 있음
  - 여러 쓰레드가 동시에 하나의 자원에 접근하는 경우, 자원 공유의 문제 발생
  - Context Switching의 오버헤드를 줄일 수 있다.

### 컨텍스트 스위칭

- **interrupt**를 발생시켜 실행중인 프로세스를 **중단**, **다른 프로세스를 처리**하기 위한 과정
  - Interrupt란? CPU가 프로세스를 실행하고 있을 때, **입출력 하드웨어** 등의 장치나 예외상황이 발생하여 **처리가 필요함**을 CPU에게 알리는 것
1. 현재 실행중인 프로세스의 상태(Context)를 저장
2. 다음 프로세스를 동작시켜 작업을 처리
3. 이전에 저장된 프로세스의 상태(Context)를 다시 복구

### 데드락

- 한정된 자원을 여러 프로세스가 사용하고자 할 때, 프로세스가 자원을 얻기 위해 영구적으로 기다리는 상태

### 메모리 관리 기법

- 메모리가 한정되어 있기 때문에 많은 프로그램들이 메모리를 사용하다보면 메모리의 **부족**과 메모리 **파편화 문제**가 발생
- **페이징 기법**
  - 메모리를 **고정된 크기의 페이지**로 나누어 관리, 페이지 단위로 메모리를 할당
  - **페이지 테이블**을 사용하여 가상 주소와 물리 주소를 매핑
    - 각 페이지가 어떤 물리적 주소에 매핑되는지에 대한 정보
    - 프로세스가 페이지를 참조할 때는 페이지 테이블을 통해 물리 주소로 변환하여 메모리에 접근
  - 고정된 크기의 페이지를 할당받으므로 메모리를 효율적으로 사용할 수 있다
- **세그먼트 기법**
  - 프로그램이 사용하는 데이터나 코드를 논리적인 단위인 세그먼트 (segment) 단위로 분할하여 메모리를 할당하는 기법
  - 세그먼트는 크기가 다르다
  - 세그먼트 테이블을 사용하여 가상 주소와 물리 주소를 매핑
  - 프로그램의 논리적인 구조를 유지하며 메모리를 할당
  - 세그먼트마다 크기가 다르므로 메모리 할당이 복잡해지고 메모리 파편화 문제가 생김.

## 6. 데이터베이스

---

### 인덱스

- 추가적인 쓰기 작업과 저장공간을 활용하여 데이터베이스 **테이블 검색 속도**를 향상시키기 위한 자료구조
- index를 적용하지 않은 칼럼을 조회한다면, 전체를 탐색하는 Full Scan이 수행된다.
- 자료구조 : 해시 테이블, B+Tree

### 트랜잭션

- 데이터베이스 작업의 단위
- 하나 이상의 쿼리를 처리할 때, 동일한 Connection 객체를 공유하여 에러가 발생할 경우 모든 과정을 되돌리기 위한 방법
- **ACID**
  - **`Atomicity` 원자성** : 트랜잭션에 포함된 작업은 전부 수행되거나 수행되지 않거나
  - **`Consistency` 일관성** : 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지
  - **`Isolation` 고립성** : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야 한다.
  - **`Durability` 지속성** : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

### RDBMS vs NoSQL

- **RDBMS**
  - 2차원의 행과 열로 데이터의 관계를 관리하는 데이터베이스
  - 스키마에 맞춰 데이터를 관리하므로 데이터의 정합성을 보장할 수 있다.
  - 시스템이 커질수록 쿼리가 복잡해진다, 수평적 확장이 어렵다
- **NoSQL**
  - RDBMS가 커지면 관계가 복잡해지는데, 이를 극복하기 위해 등장
  - 스키마 없이 Key-Value 형태로 데이터를 관리하여 더 자유롭다.
  - 중복된 데이터가 추가 가능함, 이에 대한 관리 필요




## 부록

---

### HTTP 요청 메서드

`GET` : 특정 리소스의 표시를 요청, 오직 데이터를 받기만 한다.

`POST` : 특정 리소스에 엔터티를 제출할 때

`PUT` : 목적 리소스 모든 현재 표시를 요청payload로 변경, 자원의 전체 교체, 일부만 전달되면 null/초기값 처리된다.

`PATCH` : 리소스의 부분만을 수정하는 데 사용, 일부 필드만 수정한다.

`DELETE` : 특정 리소스 삭제

### JSON과 XML

http://www.tcpschool.com/json/json_intro_xml

- e`X`tensible `M`arkup `L`anguage
- 문자 기반의 마크업 언어, 데이터를 저장하고 전달할 목적
- 태그를 사용자가 직접 정의할 수 있음
- XML 문서는 XML DOM을 이용하여 해당 문서에 접근한다.

  하지만 JSON은 문자열을 전송받은 후에 해당 문자열을 바로 파싱하므로, XML보다 더욱 처리속도가 빠르다.

  따라서 JSON은 속도가 중요한 웹 환경에서 많이 쓰인다.


### 해시 함수

- `hash`
  - 무언가를 잘게 쪼갠 후 결과물을 생성하는 과정
  - 데이터를 임의의 크기로 입력받아 고정된 크기의 출력값을 생성하는 함수
- **단방향성**
  - 입력 데이터에서 해시값으로 변환은 쉬우나, 그 역변환은 거의 불가능하다.
  - 무결성 보장, 보안 용도로 활용됨
  - 역상 저항성
- **해시 충돌**
  - 서로 다른 입력이나 동일한 해시값을 출력할 수 있음(우연)
  - 좋은 해시함수는 충돌을 최소화해야 한다.
  - 충돌 저항성
- **고정된 결과값의 길이**

### 3-way handshake 

![](https://t1.daumcdn.net/cfile/tistory/225A964D52F1BB6917?original)

- TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전, **먼저 정확한 전송을 보장**하기 위해 상대방 컴퓨터와 사전에 **세션을 수립**하는 과정
- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장

  양쪽 모두 상대편에 대한 초기 순차일렬번호(SYN)를 얻을 수 있음

1. 클라이언트 → 서버에 접속을 요청하는 **SYN 패킷 전송**

   SYN 보낸 뒤, 서버의 응답(SYN, ACK)을 기다리는 `SYN_SENT` 상태

2. 서버는 SYN 요청을 받고, **요청을 수락**한다는 **ACK와 SYN flag**가 설정된 패킷 전송

   서버는 `SYN_RECEIVED` 상태

3. 클라이언트는 SYN_SENT 상태에서 응답을 받음 → **ACK 전송**

   연결 이루어짐, 데이터가 오간다.

   서버 상태는 `ESTABLISHED`


### 4-way handshaking

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FceLHFJ%2FbtrsWKDsOqv%2FmT0tk87TAnY34Mbec9l920%2Fimg.png)

- `TIME-WAIT`
  - 먼저 연결을 끊는 쪽에서 생성되는 소켓, 혹시 모를 전송 실패에 대비하기 위해 존재하는 소켓
  - TIME-WAIT이 없다면, 패킷의 손실이 발생하거나 통신자 간 연결 해제가 제대로 되지 않을 수 있다.

### TCP (Transmission Control Protocol) 

- 신뢰성을 보장하는 연결형 서비스
- 프로그램 간에 일련의 옥텟(데이터, 메시지, 세그먼트라는 블록단위)을 `안정적`으로, `순서대로`, `에러없이` 교환
- **연결형 서비스**
  - `3-way handshaking` 과정을 통해 연결을 설정
  - `4-way handshaking` 과정을 통해 연결을 해제
- **흐름 제어**
  - 데이터 처리 속도를 조절하여 **수신자**의 버퍼 오버플로우를 방지
  - 수신자의 `윈도우 크기 값`을 통해 수신량을 정함
  - **receive window**, 얼마나 더 받을 수 있는지 공간을 알려
- **혼잡 제어**
  - 네트워크 내의 패킷 수가 넘치지 않도록 방지
  - **congestion window**
  - slow start → reno/tahoe 방식으로 유추해낸다.

    https://evan-moon.github.io/2019/11/26/tcp-congestion-control/


### UDP (User Datagram Protocol) 

- 비연결형 프로토콜
- 연결을 위해 할당되는 논리적 경로가 없음, 각각의 패킷은 다른 경로로 전송
- 데이터그램 방식 → 데이터의 전송 순서가 바뀔 수 있음
- 흐름 제어가 없음 → 제대로 전송되었는지 확인할 수 없다.
- 신뢰성보다 연속성 있는 전송이 필요할 때 사용하는 프로토콜(스트리밍)

### 대칭키, 비대칭키

- 대칭키
  - 암호화, 복호화에 똑같은 키를 쓴다
  - 빠르다, 대칭키가 노출됐을 때 위험하다.
- 비대칭키
  - 암호화, 복호화에 다른 키를 쓴다.
  - 공개키로 암호화 → 개인키로 복호화
  - 복호화에 CPU를 사용해야 한다.
  - 공개키가 노출돼도 개인키로만 복호화를 할 수 있음.

### IPC

- **inter-process communication**, IPC
- 프로세스들 사이에 **서로 데이터를 주고받는 행위** 또는 그에 대한 **방법**이나 **경로**
- 다양한 IPC 설비들
  - **PIPE**
    - 두 개의 프로세스를 연결하는 파이프
    - 하나는 쓰기만, 하나는 읽기만 가능함(반이중 통신)
    - PPID(같은 부모 프로세스)를 가지는 프로세스들 사이에서만 통신이 가능
  - **Named PIPE**
    - 부모 프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신이 가능
    - 하나는 쓰기만, 하나는 읽기만 가능함(반이중 통신)
  - **Message Queue**
    - 선입선출의 자료구조를 가지는 통신 설비
    - Named PIPE와 비슷하지만, 데이터의 흐름이 아닌 **메모리 공간**
    - 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
  - **공유 메모리**
    - 위의 3가지는 통신을 이용해 데이터를 주고받음.
    - 공유메모리는 **데이터 자체를 공유**하도록 지원하는 설비
    - 메모리 영역은 원래는 보호되지만, 프로세스가 **공유 메모리 할당**을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해줌
    - 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 가장 빠르게 작동
  - **Socket**
    - 프로세스들 사이의 통신
    - domain, type, protocol을 지정해주어야 한다.
    - 서버 : bind, listen, accept를 해주어 소켓 연결을 위한 준비를 해야함
    - 클라이언트 : connect를 통해 서버에 요청, 연결 수립된 이후 socket을 send함으로서 데이터를 주고받음
  - **Semaphore**
    - 다른 IPC 설비들은 프로세스 간 메시지 전송을 목적
    - 세마포 : 프로세스 간 **데이터**를 **동기화**하고 **보호**하는 데 목적
    - 특정 데이터를 공유하게 될 경우, 공유된 자원에 여러개의 프로세스가 동시에 접근하면 안된다. **한 번에 하나의 프로세스만 접근** 가능하도록 만들어야 함

      ⇒ 이 때 사용되는 것이 **Semaphore**