# 4.1 변수란 무엇인가? 왜 필요한가?

- **메모리**
  
  - 데이터를 저장할 수 있는 메모리 셀의 집합체
  
  - 셀 = 1byte(8bit)
  
  - 각 셀은 고유의 메모리 주소(위치)를 갖는다

- **변수**
  
  - 데이터를 사용하기 위해 메모리에 직접 접근 -> **안됨**
    
    - 시스템을 멈추게 하는 치명적 오류가 발생할 수도 있음!
    
    - 값이 저장될 때마다 메모리 주소가 바뀜 -> 동일한 값에 접근하기 어려움
  
  - 하나의 값을 저장하기 위해 **확보한 메모리 공간 자체**
  
  - **메모리 공간**을 **식별**하기 위해 붙인 이름
  
  - **값의 위치**를 가리키는 **상징적인 이름**
  
  - 변수는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다

```javascript
let result = 10 + 20
```

> * 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 `result` = **변수명**
> * 변수에 저장된 값 `10+20` = **변수값**
> * 변수에 값을 저장하는 것 = **할당, 대입**
> * 변수에 저장된 값을 읽어 들이는 것 = **참조**

# 4.2 식별자

- 어떤 값을 **구별**해서 **식별**할 수 있는 **고유한 이름**

- **메모리 상에 존재하는 어떤 값**을 식별할 수 있는 이름

- 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
  
  => 식별자는 **메모리 주소**를 기억한다

- 변수, 함수, 클래스 등...

# 4.3 변수 선언

- **변수 선언**
  
  - 값을 저장하기 위한 메모리 **공간을 확보** `allocate`
  
  - **변수 이름**과 확보된 메모리 공간의 **주소를 연결** `name binding
  
  - 변수 선언에 의해 확보된 메모리 공간은 확보가 해제 `release` 되기 전까지 공간을 사용할 수 없음

- **선언 방법**
  
  - 변수를 선언할 때 사용하는 **키워드** : `var` `let` `const`
    
    - 키워드 : 자바스크립트 엔진이 수행할 동작을 규정한 명령어

- 변수 선언 단계
  
  1. 선언 `var score`
     
     - 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알림
  
  2. 초기화 `score = 20`
     
     - 변수가 선언된 이후 최초로 값을 할당하는 것
     
     - 변수 이름을 등록하고 저장할 메모리 공간을 확보
     
     - 값을 할당하지 않으면 암묵적으로 `undefined` 로 초기화

- [참조] 변수 이름은 **어디에 등록**되는가?
  
  - **`실행 컨텍스트`**
    
    - 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역
    
    - 변수 이름과 변수 값이 실행컨텍스트 내 key-value 형식인 객체로 등록되어 관리된다.

# 4.4 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score);  // undefined
var score;           // 변수 선언문
```

- 자바스크립트는 인터프리터 언어!
  
  - 따라서 한 줄씩 실행되니까 오류가 나지 않을까? - 아마도 `referrenceError`
  
  - 결과 : **`undefined` 출력**

- 변수 선언이 일어나는 시점
  
  - 런타임(한 줄씩 순차적으로 실행되는 시점)이 아님
  
  - **그 이전 단계에서 실행!**

- 자바스크립트 엔진은 런타임 이전 **소스코드의 평가 과정**을 거친다.
  
  - 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문)을 소스코드에서 찾아내 먼저 실행

# 4.5 값의 할당

- 할당 연산자 `=`

- 우변의 값을 좌변의 변수에 할당한다
  
  > ```javascript
  > var score;    // 선언
  > score = 80;   // 할당
  > 
  > // 위와 같은 표현
  > var score = 80;
  > ```

- **문장 하나**에 **변수 선언**과 **값의 할당** 가능
  
  - 하지만, 변수 선언과 값의 할당의 **실행 시점은 다르다**

- **변수 선언** => 소스코드가 순차적으로 실행되는 시점인 **런타임 이전에** 먼저 실행

- **값의 할당** => 소스코드가 순차적으로 실행되는 시점인 **런타임**

- 변수를 할당할 때,
  
  - **`undefined`가 저장되어 있던 메모리 공간에 덮어씌우는 것이 아님**
  
  - **새로운 메모리 공간을 확보하고, 그 곳에 할당 값을 저장함.**

```javascript
console.log(ans);  // undefined

ans = 80;
var ans;

console.log(ans)   // 80
```

# 4.6 값의 재할당

> 이미 값이 할당되어 있는 변수에 **새로운 값**을 또 다시 할당하는 것

- `var` 키워드로 선언한 변수 : 재할당 가능
  
  - 엄밀히 말하면, 선언과 초기화 과정에서 초기화도 재할당이라고 할 수 있다.
  
  - 변수 선언 시 `undefined` 값이 메모리 공간에 할당되고, 초기화 실행 시 처음으로 값이 들어가니깐

- 재할당할 수 없어 변수에 저장된 값을 변경할 수 없다면, **상수** 
  
  - `const` 키워드

- 재할당은 **기존의 메모리 공간의 값을 지우는 것이 아님**!
  
  - 새로운 메모리 공간을 확보하고 그 메모리 공간에 새로운 값을 적는다
  
  - **변수와 연결된 주소가 변경**된다

- 기존의 값은, 어떤 식별자와도 연결되지 않음
  
  - 아무도 사용하지 않는 불필요한 값 `가비지 콜렉터`에 의해 메모리에서 해제됨
    
    - 어플리케이션이 할당`allocate`한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능
    
    - 자바스크립트는 가비지 콜렉터를 내장하고 있는 `매니지드 언어`
    
    - 이를 통해 메모리 누수를 방지





# 4.7 식별자 네이밍 규칙

- **식별자란**
  
  - 어떤 값을 구별해서 식별해낼 수 있는 **고유한 이름**
  
  - 식별자는 `문자`, `숫자`, `_` , `$` 를 포함할 수 있다
    
    - 문자는 `유니코드 문자`를 뜻하므로 한글도 사용할 수 있다.
  
  - 하지만 `숫자`로 시작할 수는 없다.
  
  - 예약어는 식별자로 사용할 수 없다
    
    - `let`, `const`, `await`, `break`, `case` 등..
  
  - 식별자는 대소문자를 구별한다.

- **네이밍 컨벤션**
  
  - 카멜 케이스
    
    ```javascript
    var namingConvention
    ```
  
  - 스네이크 케이스
    
    ```javascript
    var naming_convention
    ```
  
  - 파스칼 케이스
    
    ```javascript
    var NamingConvention
    ```
  
  - 헝가리언 케이스
    
    ```javascript
    var strNamingConvention  // type과 식별자
    ```

- 자바스크립트에서는...
  
  - **변수**, **함수** : `카멜 케이스`
  
  - **생성자 함수**, **클래스 이름** : `파스칼 케이스`
